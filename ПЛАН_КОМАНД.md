# План команд для КБЖУ Калькулятора

## 1. Текущее состояние

### Проблемы текущей реализации:
- Команды отправляются в LLM как обычные сообщения (`/start` → LLM)
- Нет прямой обработки команд (быстро, без запросов к API)
- Дублирование логики между `useCommands` и `messageProcessor`
- Команды не всегда работают надежно через LLM

### Преимущества команд:
- Быстрый доступ к функциям без ожидания LLM
- Экономия на API запросах
- Предсказуемое поведение
- Удобство для пользователя

---

## 2. Предлагаемый набор команд

### 2.1 Основные команды (обязательные)

#### `/start` - Создание профиля
**Описание:** Начало работы с приложением, создание профиля пользователя

**Поведение:**
- Если профиль уже существует → показать сообщение с предложением использовать `/profile`
- Если профиля нет → начать интерактивный опрос через LLM для сбора данных:
  - Рост (см)
  - Вес (кг)
  - Возраст
  - Пол (мужской/женский)
  - Уровень активности (sedentary/light/moderate/active/very_active)
  - Цель (похудение/поддержание/набор веса)
  - Целевой вес (опционально)

**Реализация:**
- Прямая обработка: проверка наличия профиля
- LLM обработка: если профиля нет, отправка в LLM с специальным промптом для создания профиля

**Влияние на UX:**
- Новые пользователи быстро понимают, с чего начать
- Четкий путь онбординга

---

#### `/profile` - Просмотр/изменение профиля
**Описание:** Просмотр текущего профиля или его изменение

**Поведение:**
- Если профиля нет → предложить создать через `/start`
- Если профиль есть:
  - Показать текущие данные профиля
  - Показать рассчитанные целевые КБЖУ
  - Предложить изменить данные (через естественный язык или уточняющие вопросы)

**Реализация:**
- Прямая обработка: получение данных из store и форматирование ответа
- LLM обработка: если пользователь хочет изменить данные, отправка в LLM

**Влияние на UX:**
- Быстрый доступ к информации о профиле
- Понятно, как изменить данные

---

#### `/add` или `/entry` - Добавление записи
**Описание:** Быстрое добавление записи о питании, весе или активности

**Поведение:**
- Открыть диалог/форму для добавления записи
- Или предложить описать в свободной форме (отправка в LLM)
- Поддержка добавления:
  - Блюда (название + опционально КБЖУ)
  - Вес
  - Физическая активность

**Реализация:**
- Вариант 1: Прямая обработка → открытие формы ввода
- Вариант 2: Отправка в LLM с промптом для извлечения данных

**Влияние на UX:**
- Быстрый способ добавить данные
- Гибкость: форма или естественный язык

---

#### `/today` - Просмотр сегодняшней записи
**Описание:** Показать что уже записано за сегодня

**Поведение:**
- Найти запись за сегодняшний день
- Показать:
  - Список блюд с КБЖУ
  - Текущий вес (если записан)
  - Активность (если записана)
  - Прогресс к целям (сколько осталось до цели)
  - Визуализация прогресса (прогресс-бары)

**Реализация:**
- Прямая обработка: поиск записи за сегодня, расчет прогресса
- Форматирование красивого ответа с эмодзи и прогресс-барами

**Влияние на UX:**
- Быстрый обзор текущего дня
- Мотивация видеть прогресс

---

#### `/stats` - Статистика
**Описание:** Показать статистику за период

**Поведение:**
- Если записей нет → предложить добавить через `/add`
- Если записи есть:
  - Показать статистику за последние 7/30 дней (или за выбранный период)
  - Средние показатели КБЖУ
  - Динамика веса
  - Графики (если доступны)
  - Сравнение с целями

**Реализация:**
- Прямая обработка: расчет статистики через `calculateStats`
- Форматирование ответа с визуализацией

**Влияние на UX:**
- Понимание прогресса
- Мотивация продолжать

---

#### `/goal` - Цели КБЖУ
**Описание:** Показать или изменить целевые КБЖУ

**Поведение:**
- Если профиля нет → предложить создать через `/start`
- Если профиль есть:
  - Показать текущие цели (рассчитанные на основе профиля)
  - Предложить изменить цели вручную
  - Объяснить, как цели связаны с профилем

**Реализация:**
- Прямая обработка: получение целей из store
- LLM обработка: если пользователь хочет изменить цели

**Влияние на UX:**
- Понятно, какие цели установлены
- Легко изменить при необходимости

---

### 2.2 Вспомогательные команды

#### `/help` - Справка
**Описание:** Показать список всех команд и их описание

**Поведение:**
- Показать список всех доступных команд
- Краткое описание каждой команды
- Примеры использования
- Советы по использованию

**Реализация:**
- Прямая обработка: форматирование списка команд из `commandHandler`

**Влияние на UX:**
- Пользователь всегда может узнать, что доступно
- Снижает барьер входа

---

#### `/export` - Экспорт данных
**Описание:** Экспортировать данные в различных форматах

**Поведение:**
- Предложить форматы: JSON, CSV, PDF
- При выборе формата → выполнить экспорт
- Сообщить об успешном экспорте

**Реализация:**
- Прямая обработка: вызов функций экспорта из `export.ts`
- Может быть реализовано как диалог выбора формата

**Влияние на UX:**
- Пользователь может сохранить свои данные
- Удобно для анализа вне приложения

---

#### `/clear` или `/reset` - Сброс данных
**Описание:** Очистить все данные (требует подтверждения)

**Поведение:**
- Показать предупреждение о том, что будет удалено
- Запросить подтверждение ("подтверждаю" или "да")
- После подтверждения → очистить все данные
- После очистки → предложить создать новый профиль

**Реализация:**
- Прямая обработка: вызов `clearAllData` после подтверждения
- Состояние подтверждения хранится в store

**Влияние на UX:**
- Безопасность: нельзя случайно удалить данные
- Возможность начать заново

---

#### `/activity` - История активности
**Описание:** Показать лог всех действий пользователя

**Поведение:**
- Показать список всех действий с временными метками
- Фильтрация по типу действия (опционально)
- Показ деталей каждого действия

**Реализация:**
- Прямая обработка: получение логов из `activityLogStore`
- Форматирование списка действий

**Влияние на UX:**
- Прозрачность: видно все действия
- Отладка: можно понять, что происходило

---

## 3. Архитектура внедрения

### 3.1 Гибридная обработка команд

**Принцип:** Команды обрабатываются в два этапа:

1. **Прямая обработка (fast path):**
   - Проверка наличия команды через `parseCommand`
   - Если команда распознана → обработка без LLM
   - Быстрый ответ пользователю
   - Экономия на API запросах

2. **LLM обработка (smart path):**
   - Если команда требует сложной логики или естественного языка
   - Если пользователь добавил дополнительный текст к команде
   - Отправка в LLM с контекстом команды

### 3.2 Структура обработчика команд

```
useChat.sendMessage()
  ↓
parseCommand(message) → Command | null
  ↓
if (command):
  → handleCommandDirectly(command) → быстрый ответ
  → if нужна LLM обработка:
      → sendToLLM(message, commandContext)
else:
  → sendToLLM(message) → обычная обработка
```

### 3.3 Новый компонент: CommandProcessor

**Файл:** `src/services/commandProcessor.ts`

**Функции:**
- `processCommand(command: Command, context: CommandContext): CommandResult`
- `shouldUseLLM(command: Command, message: string): boolean`
- `formatCommandResponse(command: Command, data: any): string`

**Типы:**
```typescript
interface CommandContext {
  profile: UserProfile | null
  entries: DailyEntry[]
  goal: KBJUGoal | null
  message: string
}

interface CommandResult {
  handled: boolean
  response?: string
  action?: 'llm' | 'direct'
  data?: any
}
```

### 3.4 Интеграция в useChat

**Изменения в `useChat.ts`:**
1. Проверка команды перед отправкой в LLM
2. Если команда → обработка через `CommandProcessor`
3. Если команда требует LLM → отправка с контекстом команды
4. Если не команда → обычная обработка через LLM

---

## 4. Детальный план внедрения

### Этап 1: Создание CommandProcessor (1-2 часа)

**Задачи:**
1. Создать файл `src/services/commandProcessor.ts`
2. Реализовать обработку простых команд:
   - `/help` - прямая обработка
   - `/profile` - прямая обработка (показ данных)
   - `/goal` - прямая обработка (показ целей)
   - `/stats` - прямая обработка (расчет статистики)
   - `/today` - прямая обработка (показ сегодняшней записи)
   - `/activity` - прямая обработка (показ логов)

**Критерии готовности:**
- Все простые команды обрабатываются без LLM
- Красивое форматирование ответов
- Корректная обработка edge cases (нет данных, нет профиля и т.д.)

---

### Этап 2: Интеграция в useChat (30 минут)

**Задачи:**
1. Модифицировать `useChat.ts`:
   - Добавить проверку команды перед отправкой в LLM
   - Вызов `CommandProcessor.processCommand()`
   - Если команда обработана → показать ответ
   - Если команда требует LLM → отправить с контекстом

**Критерии готовности:**
- Команды работают через меню
- Команды работают при вводе вручную
- Нет дублирования запросов к LLM

---

### Этап 3: Обработка команд с LLM (1-2 часа)

**Задачи:**
1. Реализовать обработку команд, требующих LLM:
   - `/start` - если профиля нет, отправка в LLM для создания
   - `/profile` - если пользователь хочет изменить, отправка в LLM
   - `/add` - отправка в LLM для извлечения данных
   - `/goal` - если пользователь хочет изменить, отправка в LLM

2. Обновить системный промпт:
   - Добавить обработку команд в промпт
   - Указать, что команды имеют приоритет

**Критерии готовности:**
- Команды с LLM работают корректно
- LLM понимает контекст команды
- Нет конфликтов между прямой обработкой и LLM

---

### Этап 4: Улучшение UX команд (1 час)

**Задачи:**
1. Добавить визуальные индикаторы:
   - Показ прогресса при обработке команды
   - Разные индикаторы для прямой обработки и LLM

2. Улучшить форматирование ответов:
   - Использование Markdown для форматирования
   - Эмодзи для визуального разделения
   - Прогресс-бары для `/today` и `/goal`

3. Добавить подсказки:
   - Автодополнение команд в инпуте
   - Подсказки при вводе `/`

**Критерии готовности:**
- Ответы команд выглядят профессионально
- Пользователю понятно, что происходит

---

### Этап 5: Тестирование и доработка (1-2 часа)

**Задачи:**
1. Протестировать все команды:
   - С профилем и без профиля
   - С данными и без данных
   - Различные комбинации

2. Исправить найденные баги
3. Оптимизировать производительность

**Критерии готовности:**
- Все команды работают стабильно
- Нет критических багов
- Хорошая производительность

---

## 5. Влияние на работу пользователя

### 5.1 Преимущества

**Скорость:**
- Команды обрабатываются мгновенно (без ожидания LLM)
- Экономия времени на частые операции

**Предсказуемость:**
- Команды всегда работают одинаково
- Нет зависимости от качества ответа LLM

**Экономия:**
- Меньше запросов к LLM API = меньше затрат
- Быстрые команды не тратят токены

**Удобство:**
- Меню команд дает быстрый доступ
- Не нужно помнить точные формулировки

### 5.2 Потенциальные проблемы и решения

**Проблема:** Пользователь может не знать о командах
**Решение:** 
- Меню команд всегда видно
- `/help` показывает все команды
- Подсказки при первом использовании

**Проблема:** Команды могут конфликтовать с естественным языком
**Решение:**
- Команды имеют приоритет
- Если команда + текст → обработка через LLM с контекстом команды

**Проблема:** Дублирование функционала (команды vs естественный язык)
**Решение:**
- Команды для быстрых действий
- Естественный язык для сложных запросов
- Оба подхода дополняют друг друга

---

## 6. Приоритизация команд

### Высокий приоритет (MVP):
1. `/start` - обязательно для онбординга
2. `/profile` - основной функционал
3. `/add` - основная функция приложения
4. `/today` - быстрый доступ к текущему дню
5. `/help` - помощь пользователю

### Средний приоритет:
6. `/stats` - полезная аналитика
7. `/goal` - управление целями
8. `/export` - экспорт данных

### Низкий приоритет:
9. `/activity` - для продвинутых пользователей
10. `/reset` - редко используется

---

## 7. Метрики успеха

**Технические:**
- Время обработки команды < 100ms (для прямых команд)
- Снижение количества запросов к LLM на 30-50%
- 0 ошибок при обработке команд

**Пользовательские:**
- 80%+ пользователей используют команды
- Среднее время выполнения задачи снижается на 40%
- Удовлетворенность пользователей повышается

---

## 8. Следующие шаги

1. **Обсуждение плана** - согласование набора команд и их поведения
2. **Начало реализации** - создание CommandProcessor
3. **Итеративная разработка** - добавление команд по приоритету
4. **Тестирование** - проверка работы всех команд
5. **Документация** - обновление README с описанием команд

---

**Дата создания:** 18 ноября 2025  
**Версия плана:** 1.0

